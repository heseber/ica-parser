{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the icaparser Python package","text":"<p>This Python package provides functions for parsing JSON files created by Illumina's Connected Annotations (ICA)pipeline.  ICA annotates mutations with \u201aa set of tools and data sources. This package allows to:</p> <ul> <li>Strip JSON files from variants that do not pass quality criteria</li> <li>Load all mutations from a stripped Illumina Connected Annotations JSON file</li> <li>Filter mutations based on annotations and positions</li> <li>Aggregate mutations to gene level</li> <li>Create annotated tables of filtered mutations</li> </ul> <p>See the examples and the API documentation for further details.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#stripping-very-large-json-files","title":"Stripping very large JSON files","text":"<p>Some JSON files from Illumina TSO panels (for example, TSO500) are not QC filtered and contain all detected genomic variants, irrespective of whether they pass the quality criteria. Such files can get very large, too large to be processed by any JSON parser. If your JSON file does not contain only QC-filtered variants (\"PASS\"), it needs to be stripped (filtered) first before using the icaparser module for further processing.</p> <p>The code below can be run in Python in a terminal or in a Jupyter notebook. Terminal is recommended.  </p> <pre><code>import icaparser as icap\nicap.strip_json_files(source_dir='../Data/Original', target_dir='../Data/Derived')\n</code></pre>"},{"location":"examples/#simple-example","title":"Simple example","text":"<p>The code below is the Hello World example for reading and filtering ICA JSON files with default filtering rules. For more sophisticated filtering options, see the API reference.</p> <pre><code>import icaparser as icap\njson_files = icap.get_dna_json_files('../Data/Derived')\nfirst_file = json_files[0]\n# Get the annotation data sources\nicap.get_data_sources(first_file)\n# Get pipeline run metadata\nicap.get_pipeline_metadata(json_files)\n# Get a mutation table\nmut_table = icap.get_mutation_table_for_files(json_files)\n</code></pre>"},{"location":"installation/","title":"Installation instructions","text":""},{"location":"installation/#installation-of-the-icaparser-package","title":"Installation of the icaparser package","text":"<p>It is recommended to create a new virtual environment with Python &gt;= 3.9 and to install the icaparser package in that environment. Activate the environment and run:</p> <pre><code>pip install \"git+https://github.com/heseber/ica-parser.git\"\n</code></pre> <p>If you want to install a particular development branch, use</p> <pre><code>pip install \"git+https://github.com/heseber/ica-parser.git@BRANCHNAME\"\n</code></pre> <p>If you use Jupyter notebooks, the virtual environment should be added as a new Jupyter kernel. See Using Virtual Environments in Jupyter Notebook and Python - Parametric Thoughts how to do that.</p>"},{"location":"installation/#installation-of-ipywidgets","title":"Installation of ipywidgets","text":"<p>Required for progress bars in Jupyter. Please refer to the Jupyter or JupyterLab documentation how to install the widgets. For example:</p> <pre><code>conda install jupyter # if not installed yet\nconda install jupyterlab_widgets\njupyter labextension install jupyter-matplotlib\njupyter lab build\nexit\n</code></pre> <p>\u2192 Restart Jupyter</p>"},{"location":"reference/","title":"API documentation","text":"<p>Parser for JSON files from Illumina Connected Annotations pipeline.</p>"},{"location":"reference/#icaparser.icaparser.add_gene_types","title":"<code>add_gene_types(positions)</code>","text":"<p>Adds the gene type to each transcript.</p> <p>Transcripts will be annotated with the gene type (oncogene, tsg, mixed) by adding a new attribute <code>geneType</code>. Only transcripts with one of these three gene types get this additional annotation. Other transcripts will not get the <code>geneType</code> attribute.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>             (<code>list</code>)         \u2013          <p>list of filtered or unfiltered positions from JSON files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>list of positions with additional annotation of transcripts.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; positions = icap.add_gene_types(positions)\n</code></pre>"},{"location":"reference/#icaparser.icaparser.apply_mutation_classification_rules","title":"<code>apply_mutation_classification_rules(positions, rule_set=get_default_mutation_classification_rules(), gene_type_map=get_default_gene_type_map(), hide_progress=False)</code>","text":"<p>Applies mutation classification rules to all positions.</p> <p>Each variant is categorized for each transcript that overlaps with the genomic position of the variant. Each transcript that passes the \"mutated\" or \"uncertain\" mutation classification rules gets a new attribute <code>mutation_status</code> with the value \"mutated\" or \"uncertain\". The input list of positions is modified by adding the <code>mutation_status</code> attribute to transcripts, and the modified list of positions is returned as the first element of the returned tuple.</p> <p>In addition to modifying and returning the list of positions, this function also returns the assembled mutation status after aggregating the impact on all transcripts covering a variant. This is returned as the second item of the returned tuple. The impact depends on the type of gene (\"gof\" or \"lof\"), so the impacts are assembled separately for each gene type.</p> <p>The impact of a particular mutational variant can be different for different overlapping transcript variants of a gene, and the transcript variants can also belong to different genes. The strongest impact on any overlapping transcript of a gene is defined as the impact of that mutational variant on the gene. The analyst must decide which isoforms are used to classify genes. For example, only canonical transcripts may be considered. Alternatively, all transcripts or a subset of transcripts may be used. Therefore, it is necessary to first apply transcript-level filters to all genomic positions before this function is called for determining the mutation status of genes.</p> <p>The returned value is a multi-dimensional dictionary:</p> <p><code>sample_id</code> \u2192 <code>gene</code> \u2192 <code>gene_type</code> \u2192 <code>variant_id</code> \u2192 <code>mutationStatus</code></p> <p>Parameters:</p> <ul> <li> <code>positions</code>             (<code>list</code>)         \u2013          <p>list of positions.</p> </li> <li> <code>rule_set</code>             (<code>dict</code>, default:                 <code>get_default_mutation_classification_rules()</code> )         \u2013          <p>rules for classifying \"gof\" and \"lof\" genes. See the default value for an example if a custom rule set is needed.</p> </li> <li> <code>gene_type_map</code>             (<code>dict</code>, default:                 <code>get_default_gene_type_map()</code> )         \u2013          <p>dictionary for mapping gene types to canonical gene types. See the default value for an example if a custom rule set is needed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[list, dict]</code>         \u2013          <p>A list of positions and a dictionary with assembled and aggregated mutations.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; positions, sample_muts = icap.apply_mutation_classification_rules(positions)\n</code></pre>"},{"location":"reference/#icaparser.icaparser.cleanup_cosmic","title":"<code>cleanup_cosmic(positions)</code>","text":"<p>Remove Cosmic entries with alleles not matching the variant alleles.</p> <p>ICA attaches Cosmic entries to variants based on position only, which leads to wrong assignments of Cosmic entries to variants. This function removes all Cosmic entries from a variant for which reference and altered alleles do not match those of the variant.</p> <p>Filtering is done in place.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>             (<code>list</code>)         \u2013          <p>list of positions to clean up.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>list of positions with cleaned up Cosmic entries.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.common_variant_filter","title":"<code>common_variant_filter(variant, max_af=0.001)</code>","text":"<p>Get a variant filter based on GnomAD, GnomAd Exome, and 1000 Genomes.</p> <p>Returns True if none of the maximum allele frequencies from GnomAD, GnomAD exomes and 1000 genomes is greater than <code>max_af</code>. The default value of 0.1 % for the maximum allele frequency corresponds to that of the AACR GENIE project.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>             (<code>dict</code>)         \u2013          <p>the variant to investigate.</p> </li> <li> <code>max_af</code>             (<code>float</code>, default:                 <code>0.001</code> )         \u2013          <p>the maximum allele frequency threshold.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if this is not a common variant.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.explode_consequence","title":"<code>explode_consequence(mutation_table, inplace=False)</code>","text":"<p>Explode the VEP consequence column of a mutation table.</p> <p>Exploding the VEP consequence column with the standard Pandas <code>explode()</code> function would return consquences as strings, not as ordered categories. This function will instead return a consequence column which is an ordered category. The categories are ordered by their impact.</p> <p>Exploding means that if a row of the input table has multiple consequences in the consequence column, the list of consequences will be split into single consequences and the output table will have multiple rows with a single consequence per row.</p> <p>Parameters:</p> <ul> <li> <code>mutation_table</code>             (<code>DataFrame</code>)         \u2013          <p>the mutation table to explode</p> </li> <li> <code>inplace</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>if True, then modify the mutation_table in place instead of returning a new object</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>new mutation table with exploded consequences.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; icap.explode_consequence(mutation_table, inplace=True)\n</code></pre> <pre><code>&gt;&gt;&gt; mutation_table_exploded = icap.explode_consequence(mutation_table)\n</code></pre>"},{"location":"reference/#icaparser.icaparser.filter_positions_by_transcripts","title":"<code>filter_positions_by_transcripts(positions, filter_func)</code>","text":"<p>Filter positions based on a filter function for transcripts.</p> <p>Apply a filter function to all transcripts of each position. Transcripts not passing the filter are removed from the variants of a position. Variants without any transcript left are removed from a position. Positions without any variants left are removed from the returned list of positions.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>             (<code>list</code>)         \u2013          <p>list of positions to filter.</p> </li> <li> <code>filter_func</code>             (<code>Callable[[dict], bool]</code>)         \u2013          <p>function taking a transcript and returning a bool. True means to keep the transcript.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>filtered positions.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_canonical_transcript = lambda x: x.get('isCanonical', False)\n&gt;&gt;&gt; canonical_positions = icap.filter_positions_by_transcripts(\n        non_common_positions,\n        is_canonical_transcript\n    )\n</code></pre>"},{"location":"reference/#icaparser.icaparser.filter_positions_by_variants","title":"<code>filter_positions_by_variants(positions, filter_func)</code>","text":"<p>Filter positions based on a filter function for variants.</p> <p>Apply a filter function to all variants of each position. Variants not passing the filter are removed from a position. Positions without any variants passing the filter are removed from the returned list.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>             (<code>list</code>)         \u2013          <p>list of positions to filter.</p> </li> <li> <code>filter_func</code>             (<code>Callable[[dict], bool]</code>)         \u2013          <p>function taking a variant and returning a bool. True means to keep the variant.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>filtered positions.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; max_af = 0.001\n&gt;&gt;&gt; is_not_common_variant = lambda x: icap.common_variant_filter(x, max_af)\n&gt;&gt;&gt; non_common_positions = icap.filter_positions_by_variants(\n        positions,\n        is_not_common_variant\n    )\n</code></pre>"},{"location":"reference/#icaparser.icaparser.filter_variants_by_transcripts","title":"<code>filter_variants_by_transcripts(variants, filter_func)</code>","text":"<p>Filter variants based on a filter function for transcripts.</p> <p>Apply a filter function to all transcripts of each variant. Transcripts not passing the filter are removed from a variant. Variants without any transcripts passing the filter are removed from the returned list.</p> <p>Parameters:</p> <ul> <li> <code>variants</code>             (<code>list</code>)         \u2013          <p>list of variants to filter.</p> </li> <li> <code>filter_func</code>             (<code>Callable[[dict], bool]</code>)         \u2013          <p>function taking a transcript and returning a bool. True means to keep the transcript.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>filtered variants.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_aggregated_mutation_table","title":"<code>get_aggregated_mutation_table(positions, sample_muts=None, mutation_classification_rules=get_default_mutation_classification_rules(), mutation_aggregation_rules=get_default_mutation_aggregation_rules(), gene_type_map=get_default_gene_type_map(), hide_progress=False)</code>","text":"<p>Returns a sample-gene-mutationStatus table.</p> <p>This function applies mutation classification rules to all mutational variants and aggregates the mutations according to the aggregation rules. This results in a table with one row for each sample-gene pair. The table contains several columns with impacts according to lof and gof rules on allele level and gene level and with one additional column with the maximum impact for both allele and gene level.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>             (<code>list</code>)         \u2013          <p>list of positions. If sample_muts is also specified, it is assumed that the positions have already been processed previously by <code>apply_mutation_classification_rules</code> and we do not have to run mutation classification again.</p> </li> <li> <code>sample_muts</code>             (<code>dict</code>, default:                 <code>None</code> )         \u2013          <p>if <code>apply_mutation_classification_rules</code> has been run before, you can use the second return value of that function as the sample_muts argument. This is helpful for very large datasets because otherwise <code>apply_mutation_classification_rules</code> will be run again as an internal call within <code>get_aggregated_mutation_table</code>, which is time consuming for very large data sets. This also means that if <code>sample_muts</code> is provided as an argument, the <code>mutation_classification_rules</code> argument is ignored and has no effect.</p> </li> <li> <code>mutation_classification_rules</code>             (<code>dict</code>, default:                 <code>get_default_mutation_classification_rules()</code> )         \u2013          <p>rules for classifying single mutations. See <code>get_default_mutation_classification_rules()</code> for details.</p> </li> <li> <code>mutation_aggregation_rules</code>             (<code>dict</code>, default:                 <code>get_default_mutation_aggregation_rules()</code> )         \u2013          <p>rules for aggregation mutations. See <code>get_default_mutation_aggregation_reles()</code> for details.</p> </li> <li> <code>gene_type_map</code>             (<code>dict</code>, default:                 <code>get_default_gene_type_map()</code> )         \u2013          <p>dictonary for mapping gene types to canonical gene types. See <code>get_default_gene_type_map()</code> for details.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>mutation table.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_biotype_priority","title":"<code>get_biotype_priority(biotype)</code>","text":"<p>Get the numeric priority of a biotype.</p> <p>The numeric priority of a biotype that is returned by this function is the same as defined by vcf2maf.pl by MSKCC. Biotypes are 'protein_coding', 'LRG_gene', ,'miRNA', ...</p> <p>Parameters:</p> <ul> <li> <code>biotype</code>             (<code>str</code>)         \u2013          <p>the biotype for which the priority is to be returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p>the priority, smaller values mean higher priority.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_clinvar","title":"<code>get_clinvar(variant)</code>","text":"<p>Get a table of all ClinVar annotations for a variant.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>             (<code>dict</code>)         \u2013          <p>the variant to investigate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>table with ClinVar annotations.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_clinvar_max_significance","title":"<code>get_clinvar_max_significance(variant, ordered_significances=_CLINVAR_ORDERED_SIGNIFICANCES)</code>","text":"<p>Get the maximum signifinance for all ClinVar annotations of a variant.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>             (<code>dict</code>)         \u2013          <p>the variant to investigate.</p> </li> <li> <code>ordered_significances</code>             (<code>list</code>, default:                 <code>_CLINVAR_ORDERED_SIGNIFICANCES</code> )         \u2013          <p>ranked order of ClinVar significances.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>ClinVar significance of highest rank for the variant.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_consequences","title":"<code>get_consequences(transcript)</code>","text":"<p>Get a list of consequences for a transcript.</p> <p>A list of consequences of a variant for a transcript is returned. If any of the annotated consequences is a combination of single consequences, separated by ampersands (&amp;) or commas, the consequence is split into single consequences.</p> <p>Parameters:</p> <ul> <li> <code>transcript</code>             (<code>dict</code>)         \u2013          <p>the transcript for which the consequences are to be returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>the consequences, a list of strings.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_cosmic_max_sample_count","title":"<code>get_cosmic_max_sample_count(variant, only_allele_specific=True)</code>","text":"<p>Get the maximum sample count for all Cosmic annotations of a variant.</p> <p>A variant can have no, one or multiple associated Cosmic identifiers. This function returns the maximum sample count of all Cosmic identifiers. For each Cosmic identifier, sample numbers are summed up across all indications. Returns 0 if no Cosmic identifier exists for this variant.</p> <p>The 'only_allele_specific' argument is used to exclude Cosmic entries that annotate the same chromosomal location but an allele that is different from the allele of the annotated variant. ICA annotates a variant with all Cosmic entries for that chromosomal location, irrespective of alleles. When counting Cosmic samples, this leads to an overestimation of Cosmic sample counts for a particular variant. Therefore, 'only_allele_specific' is True by default to count only samples from Cosmic entries with matching alleles. Occasionally, it may be desired, though, to count all samples with mutations at a given position, irrespective of allele. For example, several different alleles at a functional site of a gene can lead to function-disrupting mutations, so we want to get the maximum sample count for any allele at that position. One might also think of adding the sample counts for all Cosmic entries annotating a variant, but this does not work  due to redundancy of Cosmic entries. Older Cosmic versions often included the same sample in different Cosmic entries. And newer Cosmic versions often have multiple entries for an allele, one for each transcript variant, with the same underlying samples.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>             (<code>dict</code>)         \u2013          <p>the variant to investigate</p> </li> <li> <code>only_allele_specific</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>consider only cosmic entries with alleles                   matching the allele of the annotated variant</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p>maximum cosmic sample count</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_data_sources","title":"<code>get_data_sources(file)</code>","text":"<p>Extract a table with annotation data sources from the JSON header.</p> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>str</code>)         \u2013          <p>name of the ICA JSON file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>table with annotation data sources and their versions.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_default_gene_type_map","title":"<code>get_default_gene_type_map()</code>","text":"<p>Returns the default gene type map.</p> <p>The canonical gene types are <code>gof</code>, <code>lof</code>, and the union of both. Genes that need to be activated to drive a tumor are of type <code>gof</code>. Genes that need to be deactivated to drive a tumor are of type <code>lof</code>. Genes that need to be activated or deactivated depending on the context are of the union of both types. Genes for which it is unknown if they need to be activated or deactivated are also annotated with both types. Genes can be originally annotated with other type names than the canonical ones. The gene type map is used to map these other gene type names to the canonical gene types.</p> <p>The default map is:</p> <ul> <li><code>oncogene</code> \u2192 <code>{\"gof\"}</code></li> <li><code>tsg</code> \u2192 <code>{\"lof\"}</code></li> <li><code>Act</code> \u2192 <code>{\"gof\"}</code></li> <li><code>LoF</code> \u2192 <code>{\"lof\"}</code></li> <li><code>mixed</code> \u2192 <code>{\"gof\", \"lof\"}</code></li> <li><code>ambiguous</code> \u2192 <code>{\"gof\", \"lof\"}</code></li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>mappings from gene types to canonical gene types.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; icap.get_default_gene_type_map()\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_default_mutation_aggregation_rules","title":"<code>get_default_mutation_aggregation_rules()</code>","text":"<p>Returns the default mutation aggregation rules.</p> <p>Two types of the mutation status of a gene are defined - allele level and gene level:</p> <ul> <li>For gof genes (like oncogenes) it is sufficient that one of the   alleles of one of the relevant isoforms has an activating mutation.</li> <li>For lof genes (like tumor suppressor genes) all alleles of all   relevant isoforms need to be functionally disrupted, either by mutations   or by other means.</li> <li>For ambiguous or other genes, the impact of a mutation is defined as   the highest impact according to gof rules and lof rules.</li> </ul> <p>For gain of function (gof) genes, the classifications at both the allele and gene levels are identical unless there is supplementary information about activating modifications beyond mutations. In contrast, for loss of function (lof) genes, classifications at the allele and gene levels may diverge. For instance, a truncating mutation in a tumor suppressor gene typically disrupts the function of the affected allele. However, other alleles of the same gene may remain functionally active, meaning the gene as a whole can still be operational, unless the mutated allele is a dominant negative variant. For a gene to be considered completely dysfunctional, all its alleles must be impaired, either through additional mutations or other mechanisms such as copy number deletions or hypermethylation. Consequently, a single variant that disrupts function at the allele level does not necessarily imply disruption at the gene level.</p> <p>For loss of function (lof) genes, the available information often falls short of allowing a reliable estimation of functional effects. As a result, heuristic rules must be employed, and the analyst is tasked with deciding whether to utilize allele-level or gene-level classifications. A lof gene is classified as functionally disrupted at gene level (strong impact) if it harbors at least two mutations, each either of strong impact or of uncertain impact. Should a lof gene possess only one such mutation, it is classified as having an uncertain impact at the gene level, regardless of whether the mutation exhibits a strong impact at the allele level. By differentiating the effects at both the allele and gene levels, we maintain the flexibility to determine in subsequent analyses how to consolidate these categories for further statistical evaluations.</p> <p>The function returns a dictionary containing two keys: gof and lof. Associated with each key is a function that accepts a dictionary of counts as its input and outputs a tuple comprising two elements: the mutation status at the allele level and at the gene level. The input dictionary of counts is expected to have two keys, mutated and uncertain. The value for each key represents the number of variants within a gene classified as mutated or uncertain, respectively.</p> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>the gof and lof allele level and gene level aggregation rules.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; icap.get_default_mutation_aggregation_rules()\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_default_mutation_classification_rules","title":"<code>get_default_mutation_classification_rules(cosmic_threshold=10)</code>","text":"<p>Returns the default rules for classifying mutations.</p> <p>Defines the default rules for classifying mutations. The returned dictionary  has keys \"gof\" and \"lof\", and the respective values are the rule sets for  these gene types. Each rule set is a dictionary with the keys \"mutated\" and  \"uncertain\". The values for \"mutated\" or \"uncertain\" are dictionaries with  three filter functions, a \"position_filter\", a \"variant_filter\", and a  \"transcript_filter\". For example, a transcript will be called \"mutated\" if  all three filters for \"mutated\" return True, and it will be called  \"uncertain\", if all three filter functions for \"uncertain\" return True.</p> <p>These are the default rules returned by this function:</p> <p>GOF</p> <p>mutated: non-deleterious hotspot mutations.</p> <ul> <li>position_filter: all positions retained (no restrictions by position).</li> <li>variant_filter: keep only hotspot variants with a Cosmic sample count &gt;=     <code>cosmic_threshold</code>.</li> <li>transcript_filter: keep only amino acid sequence modifying variants that     are not most likely deleterious. This includes missense mutations and     in-frame insertions and deletions.</li> </ul> <p>uncertain: non-deleterious mutations that aren't hotspots.</p> <ul> <li>position_filter: all positions retained (no restrictions by position).</li> <li>variant_filter: keep only non-hotspot variants with a Cosmic sample count &lt;     <code>cosmic_threshold</code>.</li> <li>transcript_filter: keep only amino acid sequence modifying variants that     are not most likely deleterious. This includes missense mutations and     in-frame insertions and deletions.</li> </ul> <p>LOF</p> <p>mutated: deleterious mutations (such as truncations, start or stop codon loss).</p> <ul> <li>position_filter: all positions retained (no restrictions by position).</li> <li>variant_filter: all variants retained (no restrictions by variant).</li> <li>transcript_filter: keep only deleterious variants, such as     truncations or stop codon loss or start codon loss.</li> </ul> <p>uncertain: amino acid sequence modifying mutations that are not most likely deleterious. This includes missense mutations and in-frame insertions and deletions.</p> <ul> <li>position_filter: all positions retained (no restrictions by position).</li> <li>variant_filter: all variants retained (no restrictions by variant).</li> <li>transcript_filter: keep only amino acid sequence modifying variants that     are not most likely deleterious. This includes missense mutations and     in-frame insertions and deletions.</li> </ul> <p>Parameters:</p> <ul> <li> <code>cosmic_threshold</code>             (<code>int</code>, default:                 <code>10</code> )         \u2013          <p>for \"gof\" genes, this is the \"hotspot threshold\" for Cosmic, i.e., the minimum number of samples in Cosmic having that mutation to consider a mutation a hot spot and, therefore, call the mutation \"mutated\". If the number of Cosmic samples is smaller, the mutation is called \"uncertain\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>default mutation classification rules.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; icap.get_default_mutation_classification_rules()\n&gt;&gt;&gt; icap.get_default_mutation_classification_rules(cosmic_threshold=20)\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_dna_json_files","title":"<code>get_dna_json_files(base_dir, pattern='*MergedVariants_Annotated_filtered.json.gz')</code>","text":"<p>Find DNA annotation JSON files in or below <code>base_dir</code>.</p> <p>Searches for ICA DNA annotation JSON files in and below <code>base_dir</code>. All file names matching <code>pattern</code> are returned.</p> <p>Parameters:</p> <ul> <li> <code>base_dir</code>             (<code>str</code>)         \u2013          <p>base directory of directory subtree where to search       for DNA annotation JSON files.</p> </li> <li> <code>pattern</code>             (<code>str</code>, default:                 <code>'*MergedVariants_Annotated_filtered.json.gz'</code> )         \u2013          <p>files names matching this pattern are returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>file names.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_gene_type","title":"<code>get_gene_type(gene_symbol)</code>","text":"<p>Get the gene type (oncogene, tsg, mixed) for a gene.</p> <p>Parameters:</p> <ul> <li> <code>gene_symbol</code>             (<code>str</code>)         \u2013          <p>the gene symbol of the gene.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>the gene type.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_genes","title":"<code>get_genes(file)</code>","text":"<p>Extract gene annotation from a ICA JSON file.</p> <p>The <code>genes</code> section of ICA JSON files is optional. If this section is not included in the file, an empty list is returned.</p> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>str</code>)         \u2013          <p>name of the ICA JSON file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>gene annotations.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_gnomad_exome_max_af","title":"<code>get_gnomad_exome_max_af(variant, cohorts=['afr', 'amr', 'eas', 'nfe', 'sas'])</code>","text":"<p>Get the maximum allele frequency for gnomAD Exome.</p> <p>Get the maximum allele frequences across all major cohorts annotated by gnomAD, Exome  excluding bottleneck populations (Ashkenazy Jews and Finish) and other.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>             (<code>dict</code>)         \u2013          <p>the variant to investigate.</p> </li> <li> <code>cohorts</code>             (<code>list</code>, default:                 <code>['afr', 'amr', 'eas', 'nfe', 'sas']</code> )         \u2013          <p>subpopulations to include.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>         \u2013          <p>maximum GnomAD Exome allele frequency.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_gnomad_max_af","title":"<code>get_gnomad_max_af(variant, cohorts=['afr', 'amr', 'eas', 'nfe', 'sas'])</code>","text":"<p>Get the maximum allele frequency for gnomAD.</p> <p>Get the maximum allele frequences across all major cohorts annotated by gnomAD, excluding bottleneck populations (Ashkenazy Jews and Finish) and other.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>             (<code>dict</code>)         \u2013          <p>the variant to investigate.</p> </li> <li> <code>cohorts</code>             (<code>list</code>, default:                 <code>['afr', 'amr', 'eas', 'nfe', 'sas']</code> )         \u2013          <p>subpopulations to include.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>         \u2013          <p>maximum GnomAD allele frequency.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_header","title":"<code>get_header(file)</code>","text":"<p>Extract the header element from a ICA JSON file.</p> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>str</code>)         \u2013          <p>name of the ICA JSON file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>header from the JSON file.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_header_scalars","title":"<code>get_header_scalars(file)</code>","text":"<p>Extract a table with all scalar attributes from the JSON header.</p> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>str</code>)         \u2013          <p>name of the ICA JSON file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>table of scalar attributes and their values.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_max_af","title":"<code>get_max_af(variant, source, cohorts=None)</code>","text":"<p>Get the maximum allele frequency for a particular annotation source.</p> <p>Get the maximum allele frequency across all cohorts annotated by the annotation source.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>             (<code>dict</code>)         \u2013          <p>the variant to investigate.</p> </li> <li> <code>source</code>             (<code>str</code>)         \u2013          <p>the annotation source to use, for example 'gnomad' or 'gnomadExome' or 'oneKg'.</p> </li> <li> <code>cohorts</code>             (<code>list</code>, default:                 <code>None</code> )         \u2013          <p>subpopulations to include; include all if None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>         \u2013          <p>the maximum allele frequency.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; icap.get_max_af(variant, 'gnomad')\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_multi_sample_positions","title":"<code>get_multi_sample_positions(files, *args, **kwargs)</code>","text":"<p>Extract all positions for a set of ICA JSON files.</p> <p>The sample id is stored as an additional new attribute of the <code>samples</code> element of a position. The <code>samples</code> element is a list, although ICA usually only creates single sample JSON files.</p> <p>Parameters:</p> <ul> <li> <code>files</code>             (<code>list</code>)         \u2013          <p>names of the ICA JSON files.</p> </li> <li> <code>args</code>             (<code>object</code>, default:                 <code>()</code> )         \u2013          <p>extra arguments forwarded to get_positions().</p> </li> <li> <code>kwargs</code>             (<code>object</code>, default:                 <code>{}</code> )         \u2013          <p>extra named arguments forwarded to get_positions().</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>filtered positions from all files.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; positions = icap.get_multi_sample_positions(json_files)\n&gt;&gt;&gt; print(positions[0]['samples'][0]['sampleId'])\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_mutation_table_for_files","title":"<code>get_mutation_table_for_files(json_files, max_af=0.001, min_vep_consequence_priority=6, min_cosmic_sample_count=0, only_canonical=False, extra_variant_filters=[], extra_transcript_filters=[])</code>","text":"<p>Get an annotated table of all filtered transcripts from a list of ICA JSON files.</p> <p>Load all positions from a list of ICA JSON files and filter them. Positions having any remaining variants and transcripts passing the filter are returned as an annotated table.</p> <p>Parameters:</p> <ul> <li> <code>json_files</code>             (<code>list</code>)         \u2013          <p>list of ICA JSON files</p> </li> <li> <code>max_af</code>             (<code>float</code>, default:                 <code>0.001</code> )         \u2013          <p>maximum allele frequency for gnomAD, gnomAD Exome and 1000 Genomes.     Only variants with maximum allele frequencies below this threshold     will be returned.</p> </li> <li> <code>min_vep_consequence_priority</code>             (<code>int</code>, default:                 <code>6</code> )         \u2013          <p>only transcripts with a minimum VEP     consequence priority not larger than this threshold will be retained.     Consequences with priorities &lt;= 6 change the protein sequence,     consequences with priorities &gt; 6 do not change the protein     sequence.</p> </li> <li> <code>min_cosmic_sample_count</code>             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>only variants with a maximum cosmic sample count     not lower than this threshold will be retained</p> </li> <li> <code>only_canonical</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>if true, only canonical transcripts will be retained</p> </li> <li> <code>extra_variant_filters</code>             (<code>list</code>, default:                 <code>[]</code> )         \u2013          <p>any additional filters to apply to variants.     Filters shall return True to keep a variant.</p> </li> <li> <code>extra_transcript_filters</code>             (<code>list</code>, default:                 <code>[]</code> )         \u2013          <p>any additional filters to apply to transcripts.     Filters shall return True to keep a transcript.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>table of annotated mutations and affected transcripts.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; extra_transcript_filters = [\n        lambda x: x.get('source', '') == 'Ensembl',\n        lambda x: x.get('hgnc', '') == 'KRAS'\n    ]\n&gt;&gt;&gt; mut_table = icap.get_mutation_table_for_files(\n        json_files,\n        extra_transcript_filters=extra_transcript_filters\n    )\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_mutation_table_for_position","title":"<code>get_mutation_table_for_position(position)</code>","text":"<p>Get an annotated table of all transcripts for a single position.</p> <p>Returns an annotated table of all transcripts that are affected by a mutation at a position.</p> <p>Parameters:</p> <ul> <li> <code>position</code>             (<code>dict</code>)         \u2013          <p>the position to investigate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>table of annotated mutations and affected transcripts.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_mutation_table_for_positions","title":"<code>get_mutation_table_for_positions(positions, hide_progress=False)</code>","text":"<p>Get an annotated table of all transcripts for all positions.</p> <p>Returns an annotated table of all transcripts that are affected by a mutation at any of the positions.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>             (<code>list</code>)         \u2013          <p>the positions to investigate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>table of annotated mutations and affected transcripts.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_onekg_max_af","title":"<code>get_onekg_max_af(variant)</code>","text":"<p>Get the maximum allele frequency for the 1000 Genomes Project.</p> <p>Get the maximum allele frequences across all cohorts annotated by the 1000 Genomes Project.</p> <p>Parameters:</p> <ul> <li> <code>variant</code>             (<code>dict</code>)         \u2013          <p>the variant to investigate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>         \u2013          <p>maximum 1000 genomes allele frequency.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_pipeline_metadata","title":"<code>get_pipeline_metadata(files)</code>","text":"<p>Extract a table with metadata annotation pipeline run from the JSON header.</p> <p>Parameters:</p> <ul> <li> <code>files</code>             (<code>list</code>)         \u2013          <p>names of the ICA JSON files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>         \u2013          <p>table with metadata of pipeline runs.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_position_by_coordinates","title":"<code>get_position_by_coordinates(positions, chromosome, position)</code>","text":"<p>Extract a particular position from a position list.</p> <p>Parameters:</p> <ul> <li> <code>positions</code>             (<code>list</code>)         \u2013          <p>list of input positions.</p> </li> <li> <code>chromosome</code>             (<code>str</code>)         \u2013          <p>name of the chromosome.</p> </li> <li> <code>position</code>             (<code>int</code>)         \u2013          <p>numeric position on the chromosome.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>the position for the specified chromosome and numeric position.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import icaparser as icap\n&gt;&gt;&gt; icap.get_position_by_coordinates(positions, 'chr1', 204399064)\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_positions","title":"<code>get_positions(file, variant_filters=[], transcript_filters=[])</code>","text":"<p>Extract all positions from a ICA JSON file.</p> <p>The sample id is stored as an additional new attribute of the <code>samples</code> element of a position. The <code>samples</code> element is a list, although ICA usually only creates single sample JSON files.</p> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>str</code>)         \u2013          <p>name of the ICA JSON file</p> </li> <li> <code>variant_filters</code>             (<code>list</code>, default:                 <code>[]</code> )         \u2013          <p>any filters to apply to variants.     Filters shall return True to keep a variant.</p> </li> <li> <code>transcript_filters</code>             (<code>list</code>, default:                 <code>[]</code> )         \u2013          <p>any filters to apply to transcripts.     Filters shall return True to keep a transcript.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>         \u2013          <p>filtered positions from file.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transcript_filters = [\n        lambda x: x.get('source', '') == 'Ensembl',\n        lambda x: x.get('hgnc', '') == 'KRAS'\n    ]\n&gt;&gt;&gt; positions = icap.get_sample_positions(\n        json_file,\n        transcript_filters = transcript_filters\n    )\n&gt;&gt;&gt; print(positions[0]['samples'][0]['sampleId'])\n</code></pre>"},{"location":"reference/#icaparser.icaparser.get_sample","title":"<code>get_sample(file, suffix='(-D[^.]*)?\\\\.bam')</code>","text":"<p>Extract the sample name from a ICA JSON file.</p> <p>Parameters:</p> <ul> <li> <code>file</code>             (<code>str</code>)         \u2013          <p>name of the ICA JSON file.</p> </li> <li> <code>suffix</code>             (<code>str</code>, default:                 <code>'(-D[^.]*)?\\\\.bam'</code> )         \u2013          <p>regular expression to remove from the sample name in the JSON file. Defaults to '(-D[^.]*)?.bam'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>name of the sample annotated in the JSON file.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_strongest_vep_consequence_name","title":"<code>get_strongest_vep_consequence_name(transcript)</code>","text":"<p>Get the name of the strongest VEP consequence for a transcript.</p> <p>Parameters:</p> <ul> <li> <code>transcript</code>             (<code>dict</code>)         \u2013          <p>the transcript to investigate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>the consequence.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_strongest_vep_consequence_priority","title":"<code>get_strongest_vep_consequence_priority(transcript)</code>","text":"<p>Get the strongest priority of VEP consequence for a transcript.</p> <p>Get the strongest numeric priority of all VEP consequences for a transcript. Smaller numeric priorities mean stronger impact.</p> <p>Parameters:</p> <ul> <li> <code>transcript</code>             (<code>dict</code>)         \u2013          <p>the transcript to investigate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p>the strongest numeric priority, smaller values mean higher priority.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_strongest_vep_consequence_rank","title":"<code>get_strongest_vep_consequence_rank(transcript)</code>","text":"<p>Get the strongest rank of VEP consequences for a transcript.</p> <p>Get the strongest numeric rank of all VEP consequences for a transcript. Smaller ranks mean stronger impact.</p> <p>The priority of consequences is taken into account first. So if two consequences have different priorities, the consequence with the higher priority (lower priority number) will be used, and the rank for this consequence will be returned. If there are multiple consequences with the same priority, the lowest (strongest) rank will be returned.</p> <p>For clarification: ranks are unique, i.e. all VEP consequences ordered as listed on the VEP documentation page get the row number of this table assigned as rank.</p> <p>However, several consequences can have the same priority (e.g., stop gained and frameshift have the same priority). Priorities are copied from vcf2maf.pl of MSKCC.</p> <p>Parameters:</p> <ul> <li> <code>transcript</code>             (<code>dict</code>)         \u2013          <p>the transcript to investigate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p>the rank of the VEP consequence with strongest impact.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_vep_consequence_for_rank","title":"<code>get_vep_consequence_for_rank(rank)</code>","text":"<p>Get the VEP consequence term of a numeric rank.</p> <p>Parameters:</p> <ul> <li> <code>rank</code>             (<code>int</code>)         \u2013          <p>the numeric rank of the consequence term.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>the consequence.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.get_vep_priority_for_consequence","title":"<code>get_vep_priority_for_consequence(consequence)</code>","text":"<p>Get the numeric priority of a VEP consequence term.</p> <p>The numeric priority of a consequence that is returned by this function is   the same as defined by vcf2maf.pl of MSKCC.</p> <p>Parameters:</p> <ul> <li> <code>consequence</code>             (<code>str</code>)         \u2013          <p>the consequence term of the variant.</p> </li> </ul> <p>Returns:       the priority of the consequence, smaller values mean higher priority.</p>"},{"location":"reference/#icaparser.icaparser.get_vep_rank_for_consequence","title":"<code>get_vep_rank_for_consequence(consequence)</code>","text":"<p>Get the numeric rank of a VEP consequence term.</p> <p>The numeric rank of a consequence is the position of the consequence in this list of consequences for the Variant Effect Predictor VEP.</p> <p>Parameters:</p> <ul> <li> <code>consequence</code>             (<code>str</code>)         \u2013          <p>the consequence term of the variant.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p>the rank of the consequence, smaller values mean higher rank.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.split_multi_sample_json_file","title":"<code>split_multi_sample_json_file(json_file, output_dir)</code>","text":"<p>Splits a multi-sample JSON file into sample specific JSON files.</p> <p>This function reads a multi-sample JSON file that was generated by annotating a multi-sample VCF file with ICA and splits it into sample-specific JSON files.</p> <p>Annotating very many single-sample VCF files with ICA is very time consuming, because ICA reads all annotation sources for each VCF file and this is dominating the runtime of ICA. It is therefore helpful to first merge many single-sample VCF files into one or a small number of multi-sample VCF files (for example, with <code>bcftools merge</code>), to annotate the multi-sample VCF file with ICA, and then to split the multi-sample JSON output of ICA into single-sample JSON files. These single-sample JSON files are required for the rest of this package.</p> <p>Parameters:</p> <ul> <li> <code>json_file</code>             (<code>str</code>)         \u2013          <p>the multi-sample json input file.</p> </li> <li> <code>output_dir</code>             (<code>str</code>)         \u2013          <p>the directory where to write the single sample JSON files. The directory will be created if it does not exist.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.strip_json_file","title":"<code>strip_json_file(ifname, ofname)</code>","text":"<p>Reduce the JSON file size by keeping only 'PASS' variants.</p> <p>JSON files from Illumina's ICA pipeline can be very large because they contain any deviation from the reference genome, irrespective of the quality of the mutation call. Gzip compressed JSON files with sizes in the gigabyte range cannot be processed by JSON packages that read the entire file into memory. It is necessary to first reduce the size of JSON files by removing all variants that do not meet Illumina's quality criteria.</p> <p>This function reads a single JSON file and creates a single JSON outpout file by removing all variants that do not pass Illumina's quality criteria.</p> <p>Parameters:</p> <ul> <li> <code>ifname</code>             (<code>str</code>)         \u2013          <p>name of the input file.</p> </li> <li> <code>ofname</code>             (<code>str</code>)         \u2013          <p>name of the output file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None.</p> </li> </ul>"},{"location":"reference/#icaparser.icaparser.strip_json_files","title":"<code>strip_json_files(source_dir, target_dir, pattern='*.json.gz')</code>","text":"<p>Strip all JSON files of a project by keeping only 'PASS' variants.</p> <p>JSON files from Illumina's ICA pipeline can be very large because they contain any deviation from the reference genome, irrespective of the quality of the mutation call. Gzip compressed JSON files with sizes in the gigabyte range cannot be processed by JSON packages that read the entire file into memory. It is necessary to first reduce the size of JSON files by removing all variants that do not meet Illumina's quality criteria.</p> <p>This function searches <code>source_dir</code> recursively for all files matching the <code>file_pattern</code>. Each of those files is processed and a stripped version keeping only variants that PASS Illumina's quality criteria is created. The output file has the same name as the input file. The directory structure below <code>source_dir</code> is replicated in <code>target_dir</code>. Output files get the suffix '_filtered.json.gz'.</p> <p>Parameters:</p> <ul> <li> <code>source_dir</code>             (<code>str</code>)         \u2013          <p>directory where to search for input JSON files.</p> </li> <li> <code>target_dir</code>             (<code>str</code>)         \u2013          <p>directory where to save the stripped outpout JSON files.</p> </li> <li> <code>pattern</code>             (<code>str</code>, default:                 <code>'*.json.gz'</code> )         \u2013          <p>files matching this pattern will be processed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>         \u2013          <p>None.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; strip_json_files('../Data/Original', '../Data/Derived')\n</code></pre>"}]}